<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Yggdrasill: Quickstart</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Yggdrasill
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Quickstart </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page will guide you through the minimum steps necessary to use <a class="el" href="classygg_1_1RBTree.html" title="The Red-Black Tree. ">ygg::RBTree</a> and <a class="el" href="classygg_1_1IntervalTree.html" title="Stores an Interval Tree. ">ygg::IntervalTree</a>.</p>
<h1>Using <a class="el" href="classygg_1_1RBTree.html" title="The Red-Black Tree. ">ygg::RBTree</a> </h1>
<p>Setting up your own RBTree basically consists of three to five steps:</p>
<ol type="1">
<li>Decide on which options to set for your tree.</li>
<li>Define your Node class, inheriting from RBTreeNodeBase</li>
<li>Optionally define your own NodeTraits class (see below)</li>
<li>Optionally define an own comparator class</li>
<li>Create an RBTree based on the Node and NodeTraits class</li>
</ol>
<p>This example (which uses the defaults for steps 3 and 4 above) demonstrates it, assuming that you want to store a simple integer-to-string map in the tree:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ygg.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceygg.html">ygg</a>;</div><div class="line"></div><div class="line"><span class="comment">// The tree options</span></div><div class="line"><span class="keyword">using</span> MyTreeOptions = TreeOptions&lt;TreeFlags::MULTIPLE&gt;;</div><div class="line"></div><div class="line"><span class="comment">// The node class</span></div><div class="line"><span class="keyword">class </span>Node : <span class="keyword">public</span> <a class="code" href="classygg_1_1RBTreeNodeBase.html">RBTreeNodeBase</a>&lt;Node, MyTreeOptions&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">int</span> key;</div><div class="line">  std::string value;</div><div class="line"></div><div class="line">  <span class="comment">// need to implement this s.t. we can use the default std::less as comparator</span></div><div class="line">  <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> Node &amp; other)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> this-&gt;key &lt; other.key;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Configure the RBTree based on Node and the default NodeTraits</span></div><div class="line"><span class="keyword">using</span> MyTree = <a class="code" href="classygg_1_1RBTree.html">RBTree&lt;Node, RBDefaultNodeTraits, MyTreeOptions&gt;</a>;</div></div><!-- fragment --><p>In fact, we could have skipped defining our own TreeOptions here, since TreeFlags::MULTIPLE is the default.</p>
<p>Inserting values into the tree is then a three-step process:</p>
<ol type="1">
<li>Allocate memory for the new node (you should probably allocate multiple in one go?)</li>
<li>Set the node data</li>
<li>Insert the node into the tree</li>
</ol>
<p>Again, a simple example (based on the example above), where we just add a couple of nodes. Note that in this example, we already use the feature that we can query for anything that is comparable to a Node (in this case, we make ints comparable to Nodes first). See TODO for details.</p>
<div class="fragment"><div class="line"><span class="comment">// We need this s.t. we can query by key value (i.e, an int) directly</span></div><div class="line"><span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> Node &amp; lhs, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; rhs) {</div><div class="line">  <span class="keywordflow">return</span> lhs.key &lt; rhs;</div><div class="line">}</div><div class="line"><span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp; lhs, <span class="keyword">const</span> Node &amp; rhs) {</div><div class="line">  <span class="keywordflow">return</span> lhs &lt; rhs.key;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line">  MyTree t;</div><div class="line"></div><div class="line">  <span class="comment">// Storage for the actual nodes.</span></div><div class="line">  <span class="comment">// WARNING: using STL containers here can backfire badly. See TODO.</span></div><div class="line">  Node nodes[5];</div><div class="line"></div><div class="line">  <span class="comment">// Initialize the nodes with some values</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0 ; i &lt; 5 ; ++i) {</div><div class="line">    nodes[i].key = i;</div><div class="line">    nodes[i].value = std::string(<span class="stringliteral">&quot;The key is &quot;</span>) + std::to_string(i);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Insert them</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0 ; i &lt; 5 ; ++i) {</div><div class="line">    t.insert(nodes[i]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// What was the string for i = 3 again?</span></div><div class="line">  <span class="keyword">auto</span> it = t.find(3); <span class="comment">// Note we&#39;re using a int to query here, not a Node</span></div><div class="line">  assert(it != t.end());</div><div class="line">  std::string retrieved_value = it-&gt;value; <span class="comment">// *it is the Node</span></div><div class="line"></div><div class="line">  <span class="comment">// Okay, we don&#39;t need that Node anymore.</span></div><div class="line">  t.remove(*it);</div><div class="line">}</div></div><!-- fragment --><h1>Using <a class="el" href="classygg_1_1IntervalTree.html" title="Stores an Interval Tree. ">ygg::IntervalTree</a> </h1>
<p>Using the IntervalTree is similar to using the RBTree. You need to implement your own node. However, Intervals can not just be compared to each other using <code>operator&lt;(…)</code>, but the IntervalTree has to have access to the actual upper and lower bounds of the intervals. This is achieved by implementing the <code>get_upper()</code> and <code>get_lower()</code> methods, and setting a <code>key_type</code> typedef (or using) in the NodeTraits. You have to implement NodeTraits yourself for the IntervalTree (as opposed to the Red-Black-Tree). However, these are the only three things you have to implement. See TODO for details on implementing NodeTraits.</p>
<p>Again, an example demonstrates setting up an IntervalTree, this time mapping intervals to strings . Note that this time we do not specify our own TreeOptions, but use the default value.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ygg.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceygg.html">ygg</a>;</div><div class="line"></div><div class="line"><span class="comment">/* This class will be used by the IntervalTree to retrieve the upper and lower interval borders from the nodes.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Node&gt;</div><div class="line"><span class="keyword">class </span>NodeTraits : <span class="keyword">public</span> <a class="code" href="classygg_1_1ITreeNodeTraits.html">ITreeNodeTraits</a>&lt;Node&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> key_type = int;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> get_lower(<span class="keyword">const</span> Node &amp; node) {</div><div class="line">        <span class="keywordflow">return</span> node.lower;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> get_upper(<span class="keyword">const</span> Node &amp; node) {</div><div class="line">        <span class="keywordflow">return</span> node.upper;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* This is the node class. It provides a simple interval -&gt; value mapping, with the interval</span></div><div class="line"><span class="comment"> * borders being integers and the value being a string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">class </span>Node : <span class="keyword">public</span> <a class="code" href="classygg_1_1ITreeNodeBase.html">ITreeNodeBase</a>&lt;Node, NodeTraits&lt;Node&gt;&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> upper;</div><div class="line">    <span class="keywordtype">int</span> lower;</div><div class="line"></div><div class="line">    std::string value;</div><div class="line"></div><div class="line">    <span class="comment">// No need to implement operator&lt; here. Intervals are compared based on what</span></div><div class="line">    <span class="comment">// get_upper() and get_lower() return.</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Configure the IntervalTree</span></div><div class="line"><span class="keyword">using</span> MyTree = <a class="code" href="classygg_1_1IntervalTree.html">IntervalTree&lt;Node, NodeTraits&lt;Node&gt;</a>&gt;;</div></div><!-- fragment --><p>Setting up a tree and inserting intervals is very similar to an RBTree:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line">    (void)argc;</div><div class="line">    (void)argv;</div><div class="line"></div><div class="line">    MyTree t;</div><div class="line"></div><div class="line">    <span class="comment">// Storage for the actual nodes.</span></div><div class="line">    <span class="comment">// WARNING: using STL containers here can backfire badly. See TODO.</span></div><div class="line">    Node nodes[5];</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the nodes with some values</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0 ; i &lt; 5 ; ++i) {</div><div class="line">        nodes[i].lower = i;</div><div class="line">        nodes[i].upper = i + 10;</div><div class="line">        nodes[i].value = std::string(<span class="stringliteral">&quot;The interval is [&quot;</span>) + std::to_string(i) + std::string(<span class="stringliteral">&quot;]&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Insert them</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0 ; i &lt; 5 ; ++i) {</div><div class="line">        t.insert(nodes[i]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Querying explained below</span></div><div class="line"></div><div class="line">    <span class="comment">// Delete one node</span></div><div class="line">    t.remove(nodes[3]);</div><div class="line">}</div></div><!-- fragment --><p>Querying is a bit different from the RBTree. Since an IntervalTree is just an RBTree, you can of course again use find() to find an interval that you have previously inserted, but the really interesting queries are overlap queries.</p>
<p>Before explaining them, let me show you how the concept of types 'Comparable' to the nodes works with IntervalTrees. For a type T to be comparable to nodes, in RBTrees, you needed to implement <code>operator&lt;</code>. However, that's not used in IntervalTrees, so what to do? Easy: Your NodeTraits class must provide <code>get_upper()</code> and <code>get_lower()</code> methods for the comparable type T, too.</p>
<p>Let's say we want to represent intervals by a <code>std::pair&lt;int, int&gt;</code>, and we want to make this comparable to our Nodes. We would change the NodeTraits like so:</p>
<div class="fragment"><div class="line">…</div><div class="line"></div><div class="line"><span class="keyword">using</span> Interval = std::pair&lt;int, int&gt;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Node&gt;</div><div class="line"><span class="keyword">class </span>NodeTraits {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> key_type = int;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> get_lower(<span class="keyword">const</span> Node &amp; node) {</div><div class="line">    <span class="keywordflow">return</span> node.lower;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> get_upper(<span class="keyword">const</span> Node &amp; node) {</div><div class="line">    <span class="keywordflow">return</span> node.upper;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> get_lower(<span class="keyword">const</span> Interval &amp; i) {</div><div class="line">    <span class="keywordflow">return</span> std::get&lt;0&gt;(i);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> get_upper(<span class="keyword">const</span> Interval &amp; i) {</div><div class="line">    <span class="keywordflow">return</span> std::get&lt;1&gt;(i);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">…</div></div><!-- fragment --><p>Now you can query for nodes overlapping a certain interval:</p>
<div class="fragment"><div class="line">…</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div><div class="line">  …</div><div class="line"></div><div class="line">  Interval query_range {2, 3};</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; node : t.query(query_range))</div><div class="line">  {</div><div class="line">    <span class="comment">// This will be called with nodes 2 and 3</span></div><div class="line">  }</div><div class="line"></div><div class="line">  …</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
